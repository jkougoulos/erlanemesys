-module(probe_store).

-export([start_link/0, stop/0, add_result/2, get_results/1, get_active/0 ]).
-export([get_pstate/1, set_pstate/2, del_pstate/1, get_config/0, del_probe_pid/1, add_probe_pid/2, get_probe_pid/1, get_probe_result_count/1 ]).

-export([init/1, handle_call/3, handle_cast/2, handle_info/2, 
		code_change/3, terminate/2]).

-behaviour(gen_server).

-define( KEEP_RESULTS_SECS, 900 ).


get_config() ->
	dets:select( probe_config, [{'$1',[],['$1']}] ).

get_pstate( ProbeName ) ->
	dets:lookup( probe_config, ProbeName ). 

del_pstate( ProbeName ) ->
	gen_server:call(?MODULE, { del_pstate, ProbeName } ).

set_pstate( ProbeName, NewPstate ) ->
	gen_server:call(?MODULE, { set_pstate, { ProbeName, NewPstate } } ).

get_active() ->
	ets:foldl(  fun({Key,_Val} = _X,Acc) -> [Key|Acc] end , [] , probe_to_pid ).

start_link() ->
	gen_server:start_link({local,?MODULE}, ?MODULE, [], []).

stop() ->
	gen_server:call(?MODULE, stop).

get_probe_result_count( ProbeName ) ->
% MatchFun generated by ets:fun2ms( fun( { Key, _Val } = _X ) when Key =:= ProbeName -> true end  ),
	MatchFun = [{{'$1','$2'},[{'=:=','$1',ProbeName}],[true]}], 
	ets:select_count( probe_store_results, MatchFun ).               

add_result( ProbeName, Result ) ->
	gen_server:call( ?MODULE, { add_result, { ProbeName, Result }} ).

get_results( ProbeName ) ->
	{ ok, ets:lookup( probe_store_results, ProbeName ) }.

add_probe_pid( ProbeName, Pid ) ->
	gen_server:call( ?MODULE, { add_probe_pid, { ProbeName, Pid }} ).

del_probe_pid( ProbeName ) ->
	gen_server:call( ?MODULE, { del_probe_pid,  ProbeName} ).

get_probe_pid( ProbeName ) ->
	case ets:lookup( probe_to_pid, ProbeName ) of
		[{ _, Pid }] -> {ok, Pid};
		_ -> { error, not_found  }
	end. 

handle_call( { add_result, { ProbeName, Result } }, _From, Tid ) ->
%	{ Ms, S, Us }  = os:timestamp(),
%	ResultsTTL = { Ms, S - ?KEEP_RESULTS_SECS, Us },
%	ToBDeleted = ets:select( probe_store_results, 
%					[
%					   {{'$1',{result,'$2','$3'}},  
%					       [{'=:=','$1',ProbeName},
%					       {'<','$2',{const,ResultsTTL}}],
%					   [{{'$1',{{result,'$2','$3'}}}}]}]),
%	[ ets:delete_object( probe_store_results, Obj ) || Obj <- ToBDeleted ],
	true = ets:insert( probe_store_results, { ProbeName, Result } ),
	{ reply,  ok, Tid };

handle_call( { add_probe_pid, { ProbeName, Pid } }, _From, Tid ) ->
	true = ets:insert( probe_to_pid, { ProbeName, Pid } ),
	{ reply,  ok, Tid };

handle_call( { del_probe_pid, ProbeName }, _From, Tid ) ->
	true = ets:delete( probe_to_pid, ProbeName ),
	true = ets:delete( probe_store_results, ProbeName ),
	{ reply,  ok, Tid };

handle_call( { set_pstate, { ProbeName, NewPstate } }, _From, Tid ) ->
	ok = dets:insert( probe_config, { ProbeName, NewPstate } ),
	{ reply,  ok, Tid };

handle_call( { del_pstate, ProbeName }, _From, Tid ) ->
	ok = dets:delete( probe_config, ProbeName ),
	{ reply,  ok, Tid };

handle_call( _Msg, _From, Tid) ->
	{reply, { no_call_match_dear }, Tid }.

handle_cast( _Msg, Tid ) ->
	{reply, { no_cast_match_dear }, Tid }.
 
handle_info( _Msg, Tid ) ->
	{reply, { no_info_match_dear }, Tid }.

init([]) ->
	probe_store_results = ets:new( probe_store_results , [bag,named_table]),
	probe_to_pid = ets:new( probe_to_pid , [set,named_table]),
	{ ok, probe_config } = dets:open_file( probe_config,[{file, "probe_config.dets"},{type, set}] ),
	{ok, { dummy } }.

code_change(_OldVsn, State, _Extra) ->
		{ok, State}.
 
terminate(_Reason, _State) ->
		dets:close( probe_config ),
		ok.

